# Lab3
<!-- /TOC -->

<!-- /TOC -->


## 虚拟内存管理如何实现的：

每个进程都有自己的虚拟地址空间，通过它自己的页表将其映射到物理地址空间。每个进程的布局都是一样的，分为很多段，每个段都是一个vma,该进程的所有vma由一个mm管理起来的；
为了增大可用的内存，在磁盘上专门划分一块作为swap，通过页面置换算法完成物理页帧和磁盘的swap in/out，并在页表项上进行相应记录。在数据结构上，就是task_struct -> mm_struct -> vma_struct

## page fault产生的原因？

1. 缺页： 访问一个虚拟地址，找到对应的页表项，发现p=0, 即对应的物理页帧不在内存中。通常发生在第一次访问某个物理页时，或系统内存不足时。
2. 一般保护错：例如试图写一个只读页时，会产生保护错


## page fault的处理流程？
概述： 当cpu访问某个虚地址产生page fault，中断控制器会产生一个14号中断，并将中断请求发送给cpu，cpu根据中断号查IDT跳转到对应的中断处理例程，根据trap frame中的信息判断异常产生的原因和类型进一步分情况处理。

1. **形成trap frame**: 在操作系统中断处理程序中，处理器会将一些寄存器和状态信息保存到一个称为“陷阱帧”（trap frame）的数据结构中，以便操作系统可以恢复中断处理之前的现场。陷阱帧的具体内容因处理器和操作系统的不同而异，但通常包括以下信息：

    - 通用寄存器：通用寄存器的值（如EAX、EBX、ECX等）被保存到陷阱帧中，以便操作系统在中断处理之后可以恢复这些值。

    - 程序计数器（Program Counter）：程序计数器（PC）指向中断处理程序中的下一条指令，被保存到陷阱帧中以便操作系统可以恢复中断处理之前的执行位置。

    - 状态寄存器（Status Register）：状态寄存器包含各种处理器状态标志，例如中断使能标志和进位标志等。它的值被保存到陷阱帧中，以便操作系统可以恢复处理器状态。

    - 栈指针（Stack Pointer）：栈指针（SP）指向中断处理程序的堆栈顶部，被保存到陷阱帧中以便操作系统可以恢复中断处理之前的堆栈状态。

    - 错误代码（Error Code）：如果中断是由异常（如页面错误或保护错误）引起的，则处理器会将错误代码保存到陷阱帧中，以便操作系统可以确定异常的类型和原因。

    - 中断向量（Interrupt Vector）：中断向量是一个唯一的标识符，用于标识触发中断的硬件设备或异常类型。它的值被保存到陷阱帧中，以便操作系统可以确定中断的来源。

    - 其他信息：陷阱帧也可能包含其他信息，例如当前进程的上下文信息、中断处理程序的参数等等，具体内容因操作系统的不同而异。

2. 根据error code判断page fault产生的原因和类型，以便作进一步处理。 错误代码的位表示法因处理器和操作系统的不同而异，但通常包括以下信息：
   - 位0表示访问类型（0表示读取，1表示写入）。
   - 位1表示错误导致的原因（0表示页面不存在，1表示页面存在但不可访问）。
   - 位2表示在用户模式还是内核模式下发生页面错误（0表示用户模式，1表示内核模式）。
   - 位3表示是否由保留位（reserved bit）导致页面错误。
   - 位4表示是否由写时复制（Copy-on-Write）导致页面错误。
   - 位5表示是否由指令预取（Instruction Prefetch）导致页面错误。
   - 通过分析错误代码，操作系统可以确定页面错误的类型和原因，并采取适当的措施来处理它。

3. 列举几种情况的处理办法：
   
  - 读操作产生，且物理页不在内存中： 若有空闲物理页帧，则从swap分区加载进来；否则使用页面置换算法选择一个页换出，并把所需的页换入，并更新页表项（对于换出的页，若是脏页需要先写回磁盘并在页表项上记录swap out到swap的offset；对于换入的页，需要更新页表项P=1和物理页帧号）。最后执行iret弹出trap frame恢复上下文，重新执行读操作。
  - 写操作产生，且物理页不在内存中： 同样需要将对应的物理页加载进来，以便执行写操作。区别在于写完后，该物理页的页表项会标记为dirty，OS需要及时持久化到磁盘上
  - 试图写一个只读的页面： 产生一般保护错（genenal protect fault），通常会直接终止程序 


## 什么是脏页？

在操作系统中，当一个页面被修改后，它被标记为“脏页面”（Dirty Page）。脏页面是指已经被修改但还没有被写回到磁盘中的页面。脏页面可能包含重要的数据或者程序状态，如果不及时写回到磁盘，那么这些数据就会丢失或者不一致，可能会导致系统崩溃或者数据损坏。

当操作系统需要将一个页面从内存中换出时，如果该页面是脏页面，则操作系统会将其写回到磁盘中，以便将修改的数据持久化保存。写回操作通常是通过磁盘缓冲区（Disk Buffer）来实现的，操作系统会将脏页面的数据复制到磁盘缓冲区中，并将其标记为“待写入磁盘”。然后，操作系统会将控制权返回给用户程序，使其可以继续执行。

在后续的磁盘I/O操作中，操作系统会将磁盘缓冲区中的数据写入到磁盘中，以便持久化保存数据。写回操作通常是由磁盘控制器（Disk Controller）负责的，它们将磁盘缓冲区中的数据写入到磁盘中，并将其标记为“已写入磁盘”。一旦数据被写入磁盘中，操作系统就可以将脏页面从内存中换出，并将其空间释放出来，以便其他页面使用。

## 当访问虚地址发现物理页不在内存中时，如何知道物理页在swap中的什么位置？

页表项PTE的P位为0时，代表对应的物理页不在内存。此时PTE中的一些位表示offset，即在swap中的位置.
当页表项的P位为1时，此时offset的那些位是无效的，有其他的含义;

## 如何读写swap？

使用一些很低级的I/O函数完成对硬盘的读写，例如inb,outb,inw,outw,insl,outsl等等

## 页面置换算法如何管理所有物理页？

对于clock页面置换算法，一开始链表是空的，当第一次访问某个物理页时，会产生一次缺页，此时将该物理页用双向链表管理起来；随着不断访问不同的虚地址，会不断将物理页都添加到链表中，并由页面替换算法选择换出的页

## 页面置换算法的选择？

经典的有FIFO, LRU, LFU, CLOCK等，考虑到FIFO简单但适应性不好，LRU预测性好但复杂，因此选择了CLOCK作为ucore的页面置换算法

## 写时复制的原理？

以fork为例，当一个进程使用fork()系统调用创建一个子进程时，常常使用写时复制（Copy-on-Write，COW）机制。

在fork()调用之前，父进程和子进程共享相同的物理内存页帧。这意味着父进程和子进程的虚拟地址空间指向相同的物理页帧。
当fork()调用发生时，操作系统并不立即复制整个父进程的地址空间。相反，它使用写时复制机制来推迟页面的复制。

具体的工作流程如下：

1. 父进程和子进程共享相同的物理内存页帧。

2. 当fork()调用发生时，操作系统会创建一个新的页表用于子进程，并将子进程的页表指向父进程的页表。

3. 父进程和子进程的页表现在指向相同的物理页帧。

4. 当父进程或子进程尝试对共享页执行写操作时，操作系统会使用写时复制机制。

5. 操作系统会为发生写操作的页创建一个私有的副本，并将写操作应用于副本。这样，父进程和子进程都有了它们自己的私有页副本。

通过写时复制机制，父进程和子进程共享物理页帧，只有在需要修改共享页时才会进行复制。这样，可以避免不必要的复制开销，提高效率。

需要注意的是，写时复制机制仅在子进程或父进程尝试修改页时才会发生复制。如果父进程和子进程都只是读取共享页，实际上不会发生复制操作，它们仍然共享同一物理页帧。

写时复制机制在fork()操作中非常有用，因为它允许子进程在需要修改页时创建私有副本，而不会影响父进程的数据。这样，父进程和子进程可以共享内存空间，而无需立即复制整个地址空间。只在父子之一写操作时，复制写操作涉及到的部分物理页帧，其他物理页帧仍然共享

