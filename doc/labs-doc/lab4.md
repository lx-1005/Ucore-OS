
## 进程和线程？

一个进程拥有一个存放程序和数据的的虚拟地址空间以及其他资源。一个进程基于程序的指令流执行，其执行过程可能与其它进程的执行过程交替进行。因此，一个具有执行状态（运行态、就绪态等）的进程是一个被操作系统分配资源（比如分配内存）并调度（比如分时使用CPU）的单位。在大多数操作系统中，这两个特点是进程的主要本质特征。但这两个特征相对独立，操作系统可以把这两个特征分别进行管理。

这样可以把拥有资源所有权的单位通常仍称作进程，对资源的管理成为进程管理；把指令执行流的单位称为线程，对线程的管理就是线程调度和线程分派。对属于同一进程的所有线程而言，这些线程共享进程的虚拟地址空间和其他资源，但每个线程都有一个独立的栈，还有独立的线程运行上下文，用于包含表示线程执行现场的寄存器值等信息。

在多线程环境中，进程被定义成资源分配与保护的单位，与进程相关联的信息主要有存放进程映像的虚拟地址空间等。在一个进程中，可能有一个或多个线程，每个线程有线程执行状态（运行、就绪、等待等），保存上次运行时的线程上下文、线程的执行栈等。考虑到CPU有不同的特权模式，参照进程的分类，线程又可进一步细化为用户线程和内核线程。

到目前为止，我们就可以明确用户进程、内核进程（可把ucore看成一个内核进程）、用户线程、内核线程的区别了。从本质上看，线程就是一个特殊的不用拥有资源的轻量级进程，在ucore的调度和执行管理中，并没有区分线程和进程。且由于ucore内核中的所有内核线程共享一个内核地址空间和其他资源，所以这些内核线程从属于同一个唯一的内核进程，即ucore内核本身。理解了进程或线程的上述属性和特征，就可以进行进程/线程管理的设计与实现了。但是为了叙述上的简便，以下用户态的进程/线程统称为用户进程。


## 创建内核线程的顺序？

todo(创建用户进程和内核线程的区别)：

0号内核线程idle作用是：不停地查询，看是否有其他内核线程可以执行了，如果有，马上让调度器选择那个内核线程执行

1号init内核线程：打印“hello world”


## kstack:

kstack记录了分配给该进程/线程的内核栈的位置

所有内核线程共用同一个内核地址空间，每个线程的内核栈位置为PCB的kstack开始，大小固定为2个page，kstack就是内核线程运行程序使用的栈；对于内核线程，它没有用户地址空间，因此PCB->mm置为0，且所有内核线程共用一个页表boot_cr3.
所有内核线程的内核虚地址空间（也包括物理地址空间）是相同的。既然内核线程共用一个映射内核空间的页表，这表示内核空间对所有内核线程都是“可见”的，所以更精确地说，这些内核线程都应该是从属于同一个唯一的“大内核进程”—uCore内核。


对于用户进程，kstack就是它切换特权级时用于保存trapframe所用的栈（在切换特权级时会将其保存在TSS中），以及进入ring0执行程序时使用的栈；
同时，对于用户进程，PCB->mm会维护它的用户地址空间(不会管理它的内核地址空间)，每个进程拥有各自独立的页表PCB->mm->pgdir


## 页表：

内核地址空间只有一个，被所有进程共享； 内核有一个专门的页表boot_cr3（被所有内核线程共用），用于保存内核代码段，数据段等等；同时内核也保存了所有用户进程的页表

每个用户进程拥有自己独立的页表，所有进程的页表中映射内核地址空间的那部分都是一样的，因为都映射到了同一个内核地址空间。



## 中断帧和上下文的区别？

中断帧（trap frame）是发生中断或异常时用于保存被中断程序状态的临时数据结构，仅包含与中断处理相关的信息。它是由操作系统自动生成的，用于中断处理程序的执行和恢复被中断的程序的状态。

上下文（context）保证进程切换前后能够正确地保存和恢复进程执行状态的数据结构，是进程的完整状态信息，包括寄存器的值、内存映射、文件描述符等。 进程切换后，执行的地址是context->eip

总之，中断帧主要用于中断处理程序的执行和恢复被中断的程序的状态，而上下文则是描述进程的完整状态信息，用于进程切换和恢复。


