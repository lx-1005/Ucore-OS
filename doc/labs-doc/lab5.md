

# 内存管理：

## 虚拟内存布局：
![img_4.png](img_4.png)


整个地址空间的段布局如下（从高到低）：

内核空间段布局：

    .bss：未初始化数据段，用于存储内核的未初始化的全局变量和静态变量。

    .data.pgdir：页目录数据段，包含内核的页目录数据。

    .data：内核数据段，包含内核的可读写数据。

    .stabstr和.stab： 调试信息段，用于存储内核的调试信息。

    .rodata：只读数据段，包含内核的只读数据。

    .text：内核代码段。

用户空间段布局：

    .bss：未初始化数据段，用于存储用户程序的未初始化的全局变量和静态变量。
    
    .data：数据段，包含用户程序的可读写数据。

    .rodata：只读数据段，包含用户程序的只读数据。

    .text：用户程序的代码段。




注意：

    "Invalid Memory"不会被映射到物理内存，如果用户试图访问这些区域，会产生段错误，并由操作系统在对应的中断处理例程中进一步处理，通常会终止程序，报告错误信息

    "Empty Memory"一般也不映射，但如果有需要，用户也可以用


# 用户进程管理：（todo：等到学了文件系统就无需这种加载方式了）

idle内核线程 -> init_main内核线程 -> 把第一个应用程序填充到init_main的用户虚拟内存空间“强行”构造出第一个用户进程，并运行它，具体过程如下：

为了给用户进程建立一个能够让用户进程正常运行的用户环境(涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等)：
    
* 调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；

* 调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm->pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；

* 根据应用程序的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；
```
（链接文件user.ld和kernel.ld分别定义了可执行程序和内核的入口，以及用户/内核内存空间的布局，定义了不同段的位置； 根据user.ld得到user_hello.out，将其和内核可执行文件合在一起，并用全局变量记录了定义了user_hello.out的位置，这样该用户可执行程序就能被bootloader一起加载到内存中（随着elf内核可执行程序一起），os就可以通过全局变量确定可执行程序的不同段的位置）
```

* 调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；

* 需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址<-->物理地址映射关系；

* 至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm->pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；

* 先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；

* 此时程序运行的用户环境已经准备好，可以从程序入口开始执行了

* 在执行过程中，由于系统调用、中断和异常的发生，推动了用户进程实现用户态到到内核态的切换工作, 在中断结束后根据trapframe回到用户态接着执行

* 等到可执行程序运行结束，调用exit系统调用结束本进程（os回收绝大多数资源，并保留退出状态和pcb由其父进程回收）













# sys_fork：

主要工作在do_fork完成

* 对子进程分配一个PCB，初始化PCB相关成员：分配并初始化置内核栈kstack，用户态地址空间（用参数clone_flags区分复制还是共享），设置进程在正常运行和调度所需的中断帧trapframe和上下文context（eax会置0，作为子进程fork的返回值），

* 将设置好的PCB插入就绪队列（和哈希表中），将其设为就绪态，最终父进程返回子进程的PID，子进程返回0.

* 由于复制了上下文，其中的eip和ss决定了父子进程都会回到fork调用点后接着执行

* 当然，复制进程地址空间时，采用了cow技术，延迟复制的时间

    * 父进程调用fork时，会把它的地址空间设置为只读88（通过修改页表实现），子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并复制此物理页帧

## sys_execve:

pid不变，但将用户态地址空间完全换成新的可执行程序

# sys_exit：

进程结束时调用exit()，os完成绝大多数的资源回收。

* exit的参数会作为该进程的退出状态

* os释放大部分资源：
    * 进程的用户地址空间以及管理这些空间的内核数据结构（proc->mm, 页表）
    * 进程状态设为zombie，设置proc->exit_code=error_code
    * 打开的文件等

* 检查自己是否有子进程：
  如果自己此时还有子进程，那么将它们的父进程设置为1号init_proc

* 检查父进程是否存活

    * 如果存活，则保留内核栈和pcb，直到父进程wait/waitpid回收这两个资源

    * 如果没有，会设置父进程为1号init，进入zombie状态等待1号回收


## sys_wait:

如果此时有处于zombie状态的子进程，就回收它的pcb和内核栈，否则将自己的状态设为sleeping，并让调度器调度一个新进程运行

do_exit: 父进程等待子进程，并在得到子进程的退出消息后，彻底回收子进程所占的资源（比如子进程的内核栈和进程控制块）

## sys_putc:

将一个字符写入stdout，用于实现printf

## sys_yield 

进程主动放弃CPU资源, 检查proc->need_sched = 1，然后调度器会重新调度一个新进程

## sys_kill 

终止进程, 最终调用do_exit回收资源

## panic:

该函数调用会先输出错误信息，在调用exit系统退出该进程，并回收资源



## 如何将一个ELF格式的二进程可执行程序加载到进程中执行？

目前采用的笨办法：

1. 将其和内核可执行程序打包到一起，被bootloader一起加载到内存，根据两个全局变量（记录了用户可执行程序的位置和大小）运行
2. 利用user.ld和kernel.ld中规定的用户/内核地址空间布局，以及可执行程序入口地址，将可执行程序的不同部分加载到对应段中，并调到入口执行

等到学习了文件系统，就可以不这么做了





## 系统调用

**系统调用**：确保用户进程自己不能执行特权指令，但能够请操作系统“帮忙”完成需要特权指令，这种机制就是系统调用。采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层，这样一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。

* syscall是内核程序为用户程序提供内核服务的一种方式。 所有系统调用都使用IDT中的0x80号中断，其中断描述符中的字段DPL设置为3，表示可以以用户态主动触发该中断，这就是为什么用户态可以通过系统调用主动请求OS服务的原因；
* 当用户态程序发出一个系统调用时，查找IDT中的0x80对应的中断描述符, 根据其中的段选择子+段内offset确定中断处理例程的入口地址, 跳过去执行
* 为了正确返回用户态, 先保存用户态的trapframe. 再根据不同的系统调用，最终转化为syscall(系统调用号，若干参数), 执行不同功能的内核syscall函数
* 根据汇编代码：其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。
* 系统调用结束后，根据trapframe中保存的信息返回用户态


## 系统调用和函数调用的区别？

* 不是通过“CALL”指令而是通过“INT”指令发起调用；

* 不是通过“RET”指令，而是通过“IRET”指令完成调用返回；

* 当到达内核态后，操作系统需要严格检查系统调用传递的参数，确保不破坏整个系统的安全性；

* 执行系统调用可导致进程等待某事件发生，从而可引起进程切换；


## 进程切换？

在Linux操作系统中，每个进程都有一个对应的task_struct结构体，其中保存了进程的状态信息、时间片、进程优先级、进程内存管理信息等。
在进程执行过程中，每产生一次时钟中断，操作系统会将当前进程的时间片减1，并检查它是否已经用完了时间片。
如果当前进程的时间片已经用完，操作系统会将该进程的状态设置为就绪状态，并将其insert就绪队列，同时将need_resched标记设置为1。

每次中断执行结束时，操作系统会检查need_resched标记。如果标记为1，说明当前进程已经用完了时间片，需要切一个换新进程。
操作系统会调用schedule函数来进行进程切换，根据进程调度算法选择一个新的进程执行。
    从就绪队列中取一个进程，设置need_schedule标记为1. 在TSS中设置ring0和ring3的栈地址；通过lcr3指令切换页表；切换上下文（ 汇编写的：先保存前一个进程的上下文，再把新进程的恢复到环境中）；以上工作通过屏蔽中断的方式保证原子性（cli和sti）
等到schedule函数返回时，中断处理程序也就结束了，CPU开始执行新的进程的代码。






































